// CONFIG

SIZE = 0.5                 // particle scale and offset
SCANLINES = 8              // amount of lines rendered per frame (each pixel here is 1 group)
IMAGE_PATH = "test.bmp"    // path to target image file
X_OFF = 130                // x offset, in units
Y_OFF = 45                 // y offset, in units

// END CONFIG

extract obj_props

import "src/"
extract import "frame.spwn"
bmp_reader = import "bmp_reader.spwn"


$.print("Reading image...")
image = bmp_reader.read_bmp($.readfile(IMAGE_PATH, "bin"))

$.print(
    "\nImage width: ", image.width,
    "\nImage height: ", image.height,
    "\nScanline total pixels: ", image.width * SCANLINES,
    "\n"
)

if image.width * SCANLINES >= 9900 {
    $.print("WARNING: this might take too many groups and SPWN might fail to compile.")
}

if image.width * image.height >= 100000 {
    $.print("WARNING: this image might not be able to be fully rendered due to the resolution being too large.")
}

screen = @screen::new(X_OFF, Y_OFF + image.height * SIZE, image.width, image.height, size=SIZE, duration=9999, scanlines_nr=SCANLINES)

$.print()
img_len = image.image.length
for i in 0..SCANLINES..image.height {
    fwait(i / SCANLINES + 1)
    
    for sc in 0..SCANLINES {
        row_idx = i + sc

        if row_idx >= img_len { continue }

        row = image.image[row_idx]

        for j in 0..image.width {
            color = row[j]
            -> screen.scanlines[sc].groups[j].pulse(@chroma::from_rgb8(color[0], color[1], color[2]))
        }

        $.print("\u{001b}[2K\u{001b}[1FProcessed line: ", row_idx+1, "/", image.height)
    }
    screen.render_lines!
}